name: Build and Push Docker Image to ECR


on:
  push:
    branches:
      - 2025-01-16test 
env:
  gha-role-name: "GitHubAction-AssumeRoleWithAction"
  dockerfile-path: "./Dockerfile"
  composefile-path: "./docker-compose.yaml"
  ecr-repo-aws-region: "us-west-1"
  NETWORK: "tn-testnet"
  VALIDATOR_ROLE: "validator"
  EXPLORER_ROLE: "explorer"

permissions:
  id-token: write
  contents: write
  pull-requests: write
  actions: write

jobs:
  print_timestamp:
    uses: treasurenetprotocol/reusable-workflows/.github/workflows/reusable-timestamp.yml@main

  EnvSetup:
    needs: [ print_timestamp ]
    name: Setup Environment
    runs-on: self-hosted
    outputs:
      gha-role-name: ${{ steps.set-aws-info.outputs.gha-role-name }}
      dockerfile-path: ${{ steps.set-aws-info.outputs.dockerfile-path }}
      composefile-path: ${{ steps.set-aws-info.outputs.composefile-path }}
      ecr-repo: ${{ steps.extract-repo-name.outputs.repo-name }}
      aws-secret-name: ${{ steps.extract-repo-name.outputs.secret-name }}
      ecr-repo-aws-region: ${{ steps.set-aws-info.outputs.ecr-repo-aws-region }}
    steps:
      - name: Extract repo name
        id: extract-repo-name
        run: |
          REPO_NAME="${{ github.repository }}"
          SHORT_NAME=${REPO_NAME##*/}
          echo "repo-name=$SHORT_NAME" >> $GITHUB_OUTPUT
          echo "secret-name=testnet/$SHORT_NAME" >>$GITHUB_OUTPUT

      - name: set-aws-info
        id: set-aws-info
        run: |
          echo "ecr-repo-aws-region=${{ env.ecr-repo-aws-region }}" >> $GITHUB_OUTPUT
          echo "gha-role-name=${{ env.gha-role-name }}" >> $GITHUB_OUTPUT
          echo "dockerfile-path=${{ env.dockerfile-path }}" >> $GITHUB_OUTPUT
          echo "composefile-path=${{ env.composefile-path }}">> $GITHUB_OUTPUT

  build-scan-publish:
    needs: [ EnvSetup ]
    uses: treasurenetprotocol/reusable-workflows/.github/workflows/reusable-ecr-build-push.yml@feat/add_job_deployment
    with:
      gha-role-name: ${{ needs.EnvSetup.outputs.gha-role-name }}
      dockerfile-path: ${{ needs.EnvSetup.outputs.dockerfile-path }}
      ecr-repo: ${{ needs.EnvSetup.outputs.ecr-repo }}
      ecr-repo-aws-region: ${{ needs.EnvSetup.outputs.ecr-repo-aws-region }}
    secrets:
      AWS_MANAGEMENT_ACCOUNT: ${{ secrets.AWS_MANAGEMENT_ACCOUNT }}
      AWS_TARGET_ACCOUNT: ${{ secrets.AWS_TESTNET_ACCOUNT }}
  
  build-go-binary:
    needs: [ EnvSetup , build-scan-publish ]
    runs-on: self-hosted
    name: Build Go Binary
    steps:

      - name: Checkout code
        uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4.1.4

      - name: Set up Go
        uses: actions/setup-go@v3
        with:
          go-version: '1.18'

      - name: Build Go binary
        run: |
          echo "Building Go binary..."
          go env -w GO111MODULE=on
          go mod tidy
          make install

      - name: copy build
        run: |
          ls $(go env GOPATH)/bin
          cp $(go env GOPATH)/bin/treasurenetd .github/scripts/ansible/docker/
          sudo cp $(go env GOPATH)/bin/treasurenetd /usr/bin

      - name: Check if binary exists
        run: |
          if [ -f .github/scripts/ansible/docker/treasurenetd ]; then  
            echo "Binary file exists."
          else
            echo "Binary file does not exist."
            exit 1
          fi

      - name: init
        run: |
          chmod +x init_nodes.sh 
          chmod +x init_node_template.sh
          chmod +x node_config.json

          sudo rm -f /data/test.json
          sudo touch /data/test.json

          sudo chmod 666 /data/test.json
          sudo echo "{}" > /data/test.json
          bash init_nodes.sh

      - name: configure aws credentials
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_MANAGEMENT_ACCOUNT }}:role/${{ needs.EnvSetup.outputs.gha-role-name }}
          role-session-name: GitHub_to_AWS_via_FederatedOIDC
          aws-region: ${{ needs.EnvSetup.outputs.ecr-repo-aws-region }}

      - name: Assume role in target account
        id: assume-role-target
        run: |
          ROLE_ARN="arn:aws:iam::381492270411:role/iac-role"
          CREDS=$(aws sts assume-role --role-arn $ROLE_ARN --role-session-name GitHubAction --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' --output text)
          echo "AWS_ACCESS_KEY_ID=$(echo $CREDS | cut -d ' ' -f 1)" > .env
          echo "AWS_SECRET_ACCESS_KEY=$(echo $CREDS | cut -d ' ' -f 2)" >> .env
          echo "AWS_SESSION_TOKEN=$(echo $CREDS | cut -d ' ' -f 3)" >> .env

      

      - name: Set up environment variables and .env file
        run: |
          
          echo "IMAGE_NAME=${{ secrets.ECR_REGISTRY }}/${{ needs.EnvSetup.outputs.ecr-repo }}:${{ github.sha }}" >> .env
          echo "inputs_ecr_repo_aws_region=${{ needs.EnvSetup.outputs.ecr-repo-aws-region }}"  >> .env
          echo "secrets_ECR_REGISTRY=${{ secrets.ECR_REGISTRY }}" >> .env
          
      - name: copy env to ansible
        run: |
            cp .env .github/scripts/ansible/docker

  


deploy:
  needs: [ print_timestamp, build-go-binary ]
  runs-on: self-hosted

  steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        role-to-assume: arn:aws:iam::381492270411:role/full-ec2
        aws-region: us-west-1
        role-session-name: github-actions
        audience: GitHub_to_AWS_via_FederatedOIDC_test

    - name: Fetch EC2 IP addresses (Public and Private)
      run: |
        # Initialize empty arrays for IPs
        public_ips=()
        private_ips=()

        # Fetch IP addresses for instances with names "node1", "node2", ..., "node4"
        for i in {1..4}; do
          node_name="node$i"
          echo "Fetching IP address for instance with Name: $node_name"

          # Fetch the public IP address
          public_ip=$(aws ec2 describe-instances \
              --region us-west-1 \
              --filters "Name=tag:Name,Values=$node_name" "Name=instance-state-name,Values=running" \
              --query "Reservations[*].Instances[*].PublicIpAddress" \
              --output text)

          # Fetch the private IP address
          private_ip=$(aws ec2 describe-instances \
              --region us-west-1 \
              --filters "Name=tag:Name,Values=$node_name" "Name=instance-state-name,Values=running" \
              --query "Reservations[*].Instances[*].PrivateIpAddress" \
              --output text)

          if [ -n "$public_ip" ]; then
              public_ips+=("$public_ip")
          else
              echo "No public IP found for $node_name"
          fi

          if [ -n "$private_ip" ]; then
              private_ips+=("$private_ip")
          else
              echo "No private IP found for $node_name"
          fi
        done

        # Print the collected IPs
        echo "Public IPs: ${public_ips[@]}"
        echo "Private IPs: ${private_ips[@]}"

        # Save IPs to files
        printf "%s\n" "${public_ips[@]}" > sorted_ips.txt
        printf "%s\n" "${private_ips[@]}" > private_ips.txt

    - name: Install ansible on the runner
      run: |
        sudo apt update
        sudo apt install -y ansible

    - name: Add SSH Key
      uses: webfactory/ssh-agent@v0.5.3
      with:
        ssh-private-key: ${{ secrets.AWS_EC2_WWW_TESTNET_SSH_KEY }}

    - name: Prepare the ansible inventory file
      run: |
        rm -f inventory.ini && touch inventory.ini
        echo "[all]" > inventory.ini
        paste sorted_ips.txt private_ips.txt | while IFS=$' \t' read -r public_ip private_ip; do
          node_id="node$((i - 1))"
          echo "$public_ip ansible_user=ubuntu node_id=$node_id" >> inventory.ini
        done
        cat inventory.ini

    - name: Generate IP Mapping JSON
      run: |
        nodes=("node1" "node2" "node3" "node4")
        mapfile -t public_ips < sorted_ips.txt
        mapfile -t private_ips < private_ips.txt

        echo "{" > ip_mapping.json
        for i in "${!nodes[@]}"; do
          node=${nodes[$i]}
          public_ip=${public_ips[$i]}
          private_ip=${private_ips[$i]}

          if [ "$i" -lt "$((${#nodes[@]} - 1))" ]; then
            comma=","
          else
            comma=""
          fi

          echo "  \"$node\": {" >> ip_mapping.json
          echo "    \"public_ip\": \"$public_ip\"," >> ip_mapping.json
          echo "    \"private_ip\": \"$private_ip\"" >> ip_mapping.json
          echo "  }$comma" >> ip_mapping.json
        done

        echo "}" >> ip_mapping.json
        cat ip_mapping.json

      # - name: Modify memos and update config.toml
      #   run: |            
      #       # Declare an associative array
      #       declare -A private_ip_mapping
      #       # Declare an array to collect memos
      #       memos=()
            
      #       # Read node and private IP mappings from ip_mapping.json
      #       while read -r node public_ip private_ip; do
      #         private_ip_mapping["$node"]="$private_ip"
      #       done < <(jq -r 'to_entries[] | "\(.key) \(.value.public_ip) \(.value.private_ip)"' ip_mapping.json)
            
      #       # Iterate over each node, modify memo in gentx files and collect new memos
      #       for node in "${!private_ip_mapping[@]}"; do
      #         private_ip="${private_ip_mapping[$node]}"
              
      #         echo "Processing $node with private IP $private_ip"
              
      #         gentx_dir="/data/$node/.treasurenetd/config/gentx/"
              
      #         # Check if gentx directory exists
      #         if [ ! -d "$gentx_dir" ]; then
      #           echo "Directory $gentx_dir does not exist. Skipping..."
      #           continue
      #         fi
              
      #         # Iterate over all JSON files starting with gentx in gentx directory
      #         for json_file in "$gentx_dir"gentx*.json; do
      #           if [ -f "$json_file" ]; then
      #             echo "Modifying memo in $json_file"
                  
      #             # Extract original memo
      #             original_memo=$(jq -r '.body.memo' "$json_file")
                  
      #             # Use regular expressions to extract the content before @ and the private IP before : after @
      #             # Assume memo format is "something@IP:port"
      #             prefix=$(echo "$original_memo" | sed -E 's/@.*//')
      #             port=$(echo "$original_memo" | sed -E 's/.*:(.*)/\1/')
                  
      #             # Construct new memo
      #             new_memo="${prefix}@${private_ip}:${port}"
                  
      #             echo "Original memo: $original_memo"
      #             echo "New memo: $new_memo"
                  
      #             # Modify memo field in JSON file
      #             jq --arg new_memo "$new_memo" '.body.memo = $new_memo' "$json_file" > "${json_file}.tmp" && mv "${json_file}.tmp" "$json_file"
                  
      #             # Display the modified memo
      #             jq '.body.memo' "$json_file"
                  
      #             # Add the new memo to the memos array
      #             memos+=("$new_memo")
      #           fi
      #         done
      #       done
            
      #       # Check if any memos were collected
      #       if [ ${#memos[@]} -eq 0 ]; then
      #         echo "No memos were modified. Exiting..."
      #         exit 1
      #       fi
            
      #       # Join memos array into a comma-separated string and wrap with double quotes
      #       IFS=',' joined_memos=$(printf "%s," "${memos[@]}")
      #       joined_memos=${joined_memos%,} # Remove the trailing comma
      #       joined_memos="\"$joined_memos\""
            
      #       echo "Joined memos: $joined_memos"
            
      #       # Iterate over each node and update persistent_peers in config.toml
      #       for node in "${!private_ip_mapping[@]}"; do
      #         echo "Updating config.toml for $node"
      #         config_file="/data/$node/.treasurenetd/config/config.toml"
              
      #         # Check if config.toml file exists
      #         if [ ! -f "$config_file" ]; then
      #           echo "Config file $config_file does not exist. Skipping..."
      #           continue
      #         fi
              
      #         # Use sed to replace persistent_peers = "" with persistent_peers = "joined_memos"
      #         sed -i "s/persistent_peers = \"\"/persistent_peers = $joined_memos/" "$config_file"
              
      #         # Display the updated persistent_peers line
      #         grep 'persistent_peers' "$config_file"
      #       done
      #   shell: bash
        

    - name: new_genesis.json
      run: |
        cp ip_mapping.json .github/scripts/ansible/docker/
          
        chmod +x new_genesis.sh
          
        bash new_genesis.sh        
           
      # - name: Add EC2 instances to known_hosts
      #   run: |
      #     for ip in $(cat sorted_ips.txt); do
      #       ssh-keyscan -H $ip >> ~/.ssh/known_hosts
      #     done

      # - name: Run the ansible playbook
      #   run: |
      #     ansible-playbook -i inventory.ini .github/scripts/ansible/deploy_node.yml

      


